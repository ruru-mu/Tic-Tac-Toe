<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>中央固定マルバツゲーム</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(5, 80px);
      grid-template-rows: repeat(5, 80px);
    }

    .cell {
      width: 80px;
      height: 80px;
      font-size: 36px;
      line-height: 80px;
      text-align: center;
      vertical-align: middle;
      cursor: pointer;
      user-select: none;
      color: black;
    }

    /* 中央3x3だけ枠線を表示 */
    .visible {
      border: 1px solid #333;
      background-color: #f0f0f0;
    }

    /* 外周部分は枠線なし */
    .hidden {
      border: none;
      background-color: white;
    }

    #message {
      margin-top: 10px;
      font-size: 20px;
    }

    #currentPlayer {
      margin-top: 10px;
      font-size: 18px;
    }

    /* Custom Context Menu Styling */
    .custom-context-menu {
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .custom-context-menu li {
      padding: 8px 12px;
      cursor: pointer;
    }

    .custom-context-menu li:hover {
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <h2>マルバツゲーム</h2>
  <div id="board"></div>
  <p id="message"></p>
  <p id="currentPlayer"></p>

  <script>
    const SIZE = 5;
    const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
    const overwriteCount = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));

    let currentPlayer = "○";
    let gameOver = false;
    const boardDiv = document.getElementById("board");
    const message = document.getElementById("message");
    const currentPlayerDisplay = document.getElementById("currentPlayer");

    // 現在のプレイヤー表示を更新する関数
    function updateCurrentPlayerDisplay() {
      if (!gameOver) {
        currentPlayerDisplay.textContent = `現在のプレイヤー: ${currentPlayer}`;
      } else {
        currentPlayerDisplay.textContent = ""; // ゲーム終了時は表示をクリア
      }
    }

    // ゲームボードをレンダリングする関数
    function renderBoard() {
      boardDiv.innerHTML = ""; // ボードの内容をクリア
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");

          // 中央3x3のマスにのみ枠線と背景色を適用
          if (x >= 1 && x <= 3 && y >= 1 && y <= 3) {
            cell.classList.add("visible");
          } else {
            cell.classList.add("hidden");
          }

          const value = board[y][x];
          cell.textContent = value || ""; // マスの内容（○, ×, または空）

          // 位置情報をデータ属性として保持（ドラッグ＆ドロップ用）
          cell.dataset.x = x;
          cell.dataset.y = y;

          // マスに内容がある場合はドラッグ可能にする
          if (value) {
            cell.setAttribute("draggable", "true");

            // ドラッグ開始時の処理
            cell.ondragstart = (e) => {
              // ドラッグするマスの座標をデータとして設定
              e.dataTransfer.setData("text/plain", JSON.stringify({ fromX: x, fromY: y }));
            };
          }

          // ドラッグ中のマスの上の処理（ドロップを許可するために必要）
          cell.ondragover = (e) => {
            e.preventDefault();
          };

          // ドロップ時の処理
          cell.ondrop = (e) => {
            e.preventDefault();
            if (gameOver) return; // ゲーム終了時は何もしない

            // ドラッグ開始時のデータ（元のマスの座標）を取得
            const data = JSON.parse(e.dataTransfer.getData("text/plain"));
            const fromX = data.fromX;
            const fromY = data.fromY;

            // ドロップ先のマスの座標
            const toX = x;
            const toY = y;

            // 同じマスへの移動、または上書き回数が上限を超えている場合は移動不可
            if ((fromX === toX && fromY === toY) || overwriteCount[toY][toX] >= 2) {
              message.textContent = "そのマスには移動できません。";
              return;
            }

            const movingPlayer = board[fromY][fromX]; // 移動するマーク
            // 移動先に同じマークがある場合は移動不可
            if (board[toY][toX] === movingPlayer) {
              message.textContent = "同じマークがある場所には移動できません。";
              return;
            }

            // 移動を実行
            board[toY][toX] = movingPlayer; // 移動先にマークを配置
            board[fromY][fromX] = null; // 元のマスのマークを消去
            overwriteCount[toY][toX]++; // ドロップ先の上書き回数をカウントアップ
            message.textContent = ""; // メッセージをクリア
            renderBoard(); // ボードを再レンダリング
            updateCurrentPlayerDisplay(); // プレイヤー表示を更新
          };

          // 通常クリックによるマークの配置
          if (!gameOver) {
            cell.onclick = () => handleMove(x, y);
          } else {
            cell.style.cursor = "default"; // ゲーム終了時はカーソルをデフォルトにする
          }

          boardDiv.appendChild(cell); // ボードにセルを追加
        }
      }
      updateCurrentPlayerDisplay(); // ボードレンダリング後にプレイヤー表示を更新
    }

    // マスをクリックしたときの処理
    function handleMove(x, y) {
      if (gameOver) return; // ゲーム終了時は何もしない

      const currentValue = board[y][x]; // クリックしたマスの現在の値
      const count = overwriteCount[y][x]; // クリックしたマスの上書き回数

      // 上書き回数が上限を超えている場合は配置不可
      if (count >= 2) {
        message.textContent = "これ以上このマスには置けません。";
        return;
      }

      // 同じマークでの再配置は不可
      if (currentValue === currentPlayer) {
        message.textContent = "同じマークでの再配置はできません。";
        return;
      }

      board[y][x] = currentPlayer; // マスに現在のプレイヤーのマークを配置
      overwriteCount[y][x]++; // 上書き回数をカウントアップ

      // 勝利判定
      if (checkWin(x, y, currentPlayer)) {
        message.textContent = `${currentPlayer} の勝ち！`; // 勝利メッセージを表示
        gameOver = true; // ゲーム終了フラグを立てる
      } else {
        // 勝利でない場合はプレイヤーを交代
        currentPlayer = currentPlayer === "○" ? "×" : "○";
        message.textContent = ""; // メッセージをクリア
      }

      renderBoard(); // ボードを再レンダリング
      updateCurrentPlayerDisplay(); // プレイヤー表示を更新
    }

    // 勝利条件をチェックする関数
    function checkWin(x, y, player) {
      // チェックする方向（水平、垂直、斜め2方向）
      const directions = [
        [1, 0], [0, 1], [1, 1], [1, -1]
      ];
      // いずれかの方向に3つ以上同じマークが揃っているかチェック
      return directions.some(([dx, dy]) => {
        let count = 1;
        // 指定方向のプラス方向にチェック
        for (let i = 1; i < 3; i++) {
          // 範囲外参照を防ぐためにオプションチェイニングを使用
          if (board[y + dy * i]?.[x + dx * i] === player) count++;
          else break;
        }
        // 指定方向のマイナス方向にチェック
        for (let i = 1; i < 3; i++) {
           // 範囲外参照を防ぐためにオプションチェイニングを使用
          if (board[y - dy * i]?.[x - dx * i] === player) count++;
          else break;
        }
        return count >= 3; // 3つ以上揃っていれば勝利
      });
    }

    // 中央3x3マスを右方向に90度回転させる関数
    function rotateCenter() {
      const centerSize = 3;
      const start = 1; // 中央3x3の開始インデックス (1から3)

      // 回転後のボードと上書き回数を一時的に保持する配列
      const rotatedBoard = Array.from({ length: centerSize }, () => Array(centerSize).fill(null));
      const rotatedOverwriteCount = Array.from({ length: centerSize }, () => Array(centerSize).fill(0));

      // 回転ロジック: 元の (r, c) は回転後 (c, size - 1 - r) に移動 (0-based index for the 3x3 subgrid)
      for (let r = 0; r < centerSize; r++) {
        for (let c = 0; c < centerSize; c++) {
          rotatedBoard[c][centerSize - 1 - r] = board[start + r][start + c];
          rotatedOverwriteCount[c][centerSize - 1 - r] = overwriteCount[start + r][start + c];
        }
      }

      // 回転後の値を元のボードと上書き回数配列に反映
      for (let r = 0; r < centerSize; r++) {
        for (let c = 0; c < centerSize; c++) {
          board[start + r][start + c] = rotatedBoard[r][c];
          overwriteCount[start + r][start + c] = rotatedOverwriteCount[r][c];
        }
      }
    }


    // カスタムコンテキストメニューに関するロジック
    let customContextMenu = null; // カスタムメニュー要素を保持する変数

    // ボード上で右クリックが発生したときのイベントリスナー
    boardDiv.addEventListener('contextmenu', function(e) {
      e.preventDefault(); // デフォルトのコンテキストメニュー表示を抑制

      if (gameOver) return; // ゲーム終了時は何もしない

      // 既存のカスタムメニューがあれば削除
      if (customContextMenu) {
        customContextMenu.remove();
      }

      // カスタムメニュー要素を作成
      customContextMenu = document.createElement('ul');
      customContextMenu.classList.add('custom-context-menu');
      // 右クリックした位置にメニューを配置
      customContextMenu.style.top = `${e.clientY}px`;
      customContextMenu.style.left = `${e.clientX}px`;

      // 「勝利」オプションを作成
      const victoryOption = document.createElement('li');
      victoryOption.textContent = '勝利';
      // 「勝利」オプションがクリックされたときの処理
      victoryOption.addEventListener('click', function() {
        if (!gameOver) { // ゲームがまだ終了していない場合のみ処理を実行
          message.textContent = `${currentPlayer} の勝ち！`; // 勝利メッセージを表示
          gameOver = true; // ゲーム終了フラグを立てる
          renderBoard(); // ボードを再レンダリングしてクリックを無効化
          updateCurrentPlayerDisplay(); // プレイヤー表示を更新
        }
        customContextMenu.remove(); // メニューを削除
        customContextMenu = null; // 変数をクリア
      });
      customContextMenu.appendChild(victoryOption); // メニューにオプションを追加

      // 「回転」オプションを作成
      const rotateOption = document.createElement('li');
      rotateOption.textContent = '回転';
      // 「回転」オプションがクリックされたときの処理
      rotateOption.addEventListener('click', function() {
        if (!gameOver) { // ゲームがまだ終了していない場合のみ処理を実行
          rotateCenter(); // 中央マスを回転
          renderBoard(); // ボードを再レンダリング
          updateCurrentPlayerDisplay(); // プレイヤー表示を更新
          message.textContent = "中央のマスが回転しました。"; // 回転メッセージを表示
        }
        customContextMenu.remove(); // メニューを削除
        customContextMenu = null; // 変数をクリア
      });
      customContextMenu.appendChild(rotateOption); // メニューにオプションを追加


      // メニューをbodyに追加して表示
      document.body.appendChild(customContextMenu);
    });

    // ドキュメント全体でクリックが発生したときのイベントリスナー
    document.addEventListener('click', function(e) {
      // カスタムメニューが表示されていて、クリックされた要素がメニューの外側であればメニューを非表示にする
      if (customContextMenu && !customContextMenu.contains(e.target)) {
        customContextMenu.remove(); // メニューを削除
        customContextMenu = null; // 変数をクリア
      }
    });


    // ゲーム開始時の初期レンダリングと表示更新
    renderBoard();
    updateCurrentPlayerDisplay();
  </script>
</body>
</html>
